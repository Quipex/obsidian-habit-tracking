/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs = require("fs");
    function checkPathExt(path, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path, options);
    }
    function isexe(path, options, cb) {
      fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path, options));
      });
    }
    function sync(path, options) {
      return checkStat(fs.statSync(path), path, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs = require("fs");
    function isexe(path, options, cb) {
      fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path, options) {
      return checkStat(fs.statSync(path), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports2, module2) {
    var fs = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path, options) {
      try {
        return core.sync(path, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports2, module2) {
    module2.exports = which;
    which.sync = whichSync;
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    function getNotFoundError(cmd) {
      var er = new Error("not found: " + cmd);
      er.code = "ENOENT";
      return er;
    }
    function getPathInfo(cmd, opt) {
      var colon = opt.colon || COLON;
      var pathEnv = opt.path || process.env.PATH || "";
      var pathExt = [""];
      pathEnv = pathEnv.split(colon);
      var pathExtExe = "";
      if (isWindows) {
        pathEnv.unshift(process.cwd());
        pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
        pathExt = pathExtExe.split(colon);
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
        pathEnv = [""];
      return {
        env: pathEnv,
        ext: pathExt,
        extExe: pathExtExe
      };
    }
    function which(cmd, opt, cb) {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      (function F(i, l) {
        if (i === l) {
          if (opt.all && found.length)
            return cb(null, found);
          else
            return cb(getNotFoundError(cmd));
        }
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        ;
        (function E(ii, ll) {
          if (ii === ll)
            return F(i + 1, l);
          var ext = pathExt[ii];
          isexe(p + ext, { pathExt: pathExtExe }, function(er, is) {
            if (!er && is) {
              if (opt.all)
                found.push(p + ext);
              else
                return cb(null, p + ext);
            }
            return E(ii + 1, ll);
          });
        })(0, pathExt.length);
      })(0, pathEnv.length);
    }
    function whichSync(cmd, opt) {
      opt = opt || {};
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      for (var i = 0, l = pathEnv.length; i < l; i++) {
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        for (var j = 0, ll = pathExt.length; j < ll; j++) {
          var cur = p + pathExt[j];
          var is;
          try {
            is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    }
  }
});

// node_modules/pseudomap/pseudomap.js
var require_pseudomap = __commonJS({
  "node_modules/pseudomap/pseudomap.js"(exports2, module2) {
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    module2.exports = PseudoMap;
    function PseudoMap(set2) {
      if (!(this instanceof PseudoMap))
        throw new TypeError("Constructor PseudoMap requires 'new'");
      this.clear();
      if (set2) {
        if (set2 instanceof PseudoMap || typeof Map === "function" && set2 instanceof Map)
          set2.forEach(function(value, key) {
            this.set(key, value);
          }, this);
        else if (Array.isArray(set2))
          set2.forEach(function(kv) {
            this.set(kv[0], kv[1]);
          }, this);
        else
          throw new TypeError("invalid argument");
      }
    }
    PseudoMap.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      Object.keys(this._data).forEach(function(k) {
        if (k !== "size")
          fn.call(thisp, this._data[k].value, this._data[k].key);
      }, this);
    };
    PseudoMap.prototype.has = function(k) {
      return !!find(this._data, k);
    };
    PseudoMap.prototype.get = function(k) {
      var res = find(this._data, k);
      return res && res.value;
    };
    PseudoMap.prototype.set = function(k, v) {
      set(this._data, k, v);
    };
    PseudoMap.prototype.delete = function(k) {
      var res = find(this._data, k);
      if (res) {
        delete this._data[res._index];
        this._data.size--;
      }
    };
    PseudoMap.prototype.clear = function() {
      var data = /* @__PURE__ */ Object.create(null);
      data.size = 0;
      Object.defineProperty(this, "_data", {
        value: data,
        enumerable: false,
        configurable: true,
        writable: false
      });
    };
    Object.defineProperty(PseudoMap.prototype, "size", {
      get: function() {
        return this._data.size;
      },
      set: function(n) {
      },
      enumerable: true,
      configurable: true
    });
    PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {
      throw new Error("iterators are not implemented in this version");
    };
    function same(a, b) {
      return a === b || a !== a && b !== b;
    }
    function Entry(k, v, i) {
      this.key = k;
      this.value = v;
      this._index = i;
    }
    function find(data, k) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
        if (same(data[key].key, k))
          return data[key];
      }
    }
    function set(data, k, v) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
        if (same(data[key].key, k)) {
          data[key].value = v;
          return;
        }
      }
      data.size++;
      data[key] = new Entry(k, v, key);
    }
  }
});

// node_modules/pseudomap/map.js
var require_map = __commonJS({
  "node_modules/pseudomap/map.js"(exports2, module2) {
    if (process.env.npm_package_name === "pseudomap" && process.env.npm_lifecycle_script === "test")
      process.env.TEST_PSEUDOMAP = "true";
    if (typeof Map === "function" && !process.env.TEST_PSEUDOMAP) {
      module2.exports = Map;
    } else {
      module2.exports = require_pseudomap();
    }
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports2, module2) {
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (!(self instanceof Yallist)) {
        self = new Yallist();
      }
      self.tail = null;
      self.head = null;
      self.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    module2.exports = LRUCache;
    var Map2 = require_map();
    var util = require("util");
    var Yallist = require_yallist();
    var hasSymbol = typeof Symbol === "function" && process.env._nodeLRUCacheForceNoSymbol !== "1";
    var makeSymbol;
    if (hasSymbol) {
      makeSymbol = function(key) {
        return Symbol(key);
      };
    } else {
      makeSymbol = function(key) {
        return "_" + key;
      };
    }
    var MAX = makeSymbol("max");
    var LENGTH = makeSymbol("length");
    var LENGTH_CALCULATOR = makeSymbol("lengthCalculator");
    var ALLOW_STALE = makeSymbol("allowStale");
    var MAX_AGE = makeSymbol("maxAge");
    var DISPOSE = makeSymbol("dispose");
    var NO_DISPOSE_ON_SET = makeSymbol("noDisposeOnSet");
    var LRU_LIST = makeSymbol("lruList");
    var CACHE = makeSymbol("cache");
    function naiveLength() {
      return 1;
    }
    function LRUCache(options) {
      if (!(this instanceof LRUCache)) {
        return new LRUCache(options);
      }
      if (typeof options === "number") {
        options = { max: options };
      }
      if (!options) {
        options = {};
      }
      var max = this[MAX] = options.max;
      if (!max || !(typeof max === "number") || max <= 0) {
        this[MAX] = Infinity;
      }
      var lc = options.length || naiveLength;
      if (typeof lc !== "function") {
        lc = naiveLength;
      }
      this[LENGTH_CALCULATOR] = lc;
      this[ALLOW_STALE] = options.stale || false;
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this.reset();
    }
    Object.defineProperty(LRUCache.prototype, "max", {
      set: function(mL) {
        if (!mL || !(typeof mL === "number") || mL <= 0) {
          mL = Infinity;
        }
        this[MAX] = mL;
        trim(this);
      },
      get: function() {
        return this[MAX];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "allowStale", {
      set: function(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      },
      get: function() {
        return this[ALLOW_STALE];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "maxAge", {
      set: function(mA) {
        if (!mA || !(typeof mA === "number") || mA < 0) {
          mA = 0;
        }
        this[MAX_AGE] = mA;
        trim(this);
      },
      get: function() {
        return this[MAX_AGE];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
      set: function(lC) {
        if (typeof lC !== "function") {
          lC = naiveLength;
        }
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach(function(hit) {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          }, this);
        }
        trim(this);
      },
      get: function() {
        return this[LENGTH_CALCULATOR];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "length", {
      get: function() {
        return this[LENGTH];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "itemCount", {
      get: function() {
        return this[LRU_LIST].length;
      },
      enumerable: true
    });
    LRUCache.prototype.rforEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].tail; walker !== null; ) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    };
    function forEachStep(self, fn, node, thisp) {
      var hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE]) {
          hit = void 0;
        }
      }
      if (hit) {
        fn.call(thisp, hit.value, hit.key, self);
      }
    }
    LRUCache.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].head; walker !== null; ) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    };
    LRUCache.prototype.keys = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.key;
      }, this);
    };
    LRUCache.prototype.values = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.value;
      }, this);
    };
    LRUCache.prototype.reset = function() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function(hit) {
          this[DISPOSE](hit.key, hit.value);
        }, this);
      }
      this[CACHE] = new Map2();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    };
    LRUCache.prototype.dump = function() {
      return this[LRU_LIST].map(function(hit) {
        if (!isStale(this, hit)) {
          return {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          };
        }
      }, this).toArray().filter(function(h) {
        return h;
      });
    };
    LRUCache.prototype.dumpLru = function() {
      return this[LRU_LIST];
    };
    LRUCache.prototype.inspect = function(n, opts) {
      var str = "LRUCache {";
      var extras = false;
      var as = this[ALLOW_STALE];
      if (as) {
        str += "\n  allowStale: true";
        extras = true;
      }
      var max = this[MAX];
      if (max && max !== Infinity) {
        if (extras) {
          str += ",";
        }
        str += "\n  max: " + util.inspect(max, opts);
        extras = true;
      }
      var maxAge = this[MAX_AGE];
      if (maxAge) {
        if (extras) {
          str += ",";
        }
        str += "\n  maxAge: " + util.inspect(maxAge, opts);
        extras = true;
      }
      var lc = this[LENGTH_CALCULATOR];
      if (lc && lc !== naiveLength) {
        if (extras) {
          str += ",";
        }
        str += "\n  length: " + util.inspect(this[LENGTH], opts);
        extras = true;
      }
      var didFirst = false;
      this[LRU_LIST].forEach(function(item) {
        if (didFirst) {
          str += ",\n  ";
        } else {
          if (extras) {
            str += ",\n";
          }
          didFirst = true;
          str += "\n  ";
        }
        var key = util.inspect(item.key).split("\n").join("\n  ");
        var val = { value: item.value };
        if (item.maxAge !== maxAge) {
          val.maxAge = item.maxAge;
        }
        if (lc !== naiveLength) {
          val.length = item.length;
        }
        if (isStale(this, item)) {
          val.stale = true;
        }
        val = util.inspect(val, opts).split("\n").join("\n  ");
        str += key + " => " + val;
      });
      if (didFirst || extras) {
        str += "\n";
      }
      str += "}";
      return str;
    };
    LRUCache.prototype.set = function(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        var node = this[CACHE].get(key);
        var item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) {
            this[DISPOSE](key, item.value);
          }
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      var hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) {
          this[DISPOSE](key, value);
        }
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    };
    LRUCache.prototype.has = function(key) {
      if (!this[CACHE].has(key))
        return false;
      var hit = this[CACHE].get(key).value;
      if (isStale(this, hit)) {
        return false;
      }
      return true;
    };
    LRUCache.prototype.get = function(key) {
      return get(this, key, true);
    };
    LRUCache.prototype.peek = function(key) {
      return get(this, key, false);
    };
    LRUCache.prototype.pop = function() {
      var node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    };
    LRUCache.prototype.del = function(key) {
      del(this, this[CACHE].get(key));
    };
    LRUCache.prototype.load = function(arr) {
      this.reset();
      var now = Date.now();
      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) {
          this.set(hit.k, hit.v);
        } else {
          var maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    };
    LRUCache.prototype.prune = function() {
      var self = this;
      this[CACHE].forEach(function(value, key) {
        get(self, key, false);
      });
    };
    function get(self, key, doUse) {
      var node = self[CACHE].get(key);
      if (node) {
        var hit = node.value;
        if (isStale(self, hit)) {
          del(self, node);
          if (!self[ALLOW_STALE])
            hit = void 0;
        } else {
          if (doUse) {
            self[LRU_LIST].unshiftNode(node);
          }
        }
        if (hit)
          hit = hit.value;
      }
      return hit;
    }
    function isStale(self, hit) {
      if (!hit || !hit.maxAge && !self[MAX_AGE]) {
        return false;
      }
      var stale = false;
      var diff = Date.now() - hit.now;
      if (hit.maxAge) {
        stale = diff > hit.maxAge;
      } else {
        stale = self[MAX_AGE] && diff > self[MAX_AGE];
      }
      return stale;
    }
    function trim(self) {
      if (self[LENGTH] > self[MAX]) {
        for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          var prev = walker.prev;
          del(self, walker);
          walker = prev;
        }
      }
    }
    function del(self, node) {
      if (node) {
        var hit = node.value;
        if (self[DISPOSE]) {
          self[DISPOSE](hit.key, hit.value);
        }
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
      }
    }
    function Entry(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var which = require_which();
    var LRU = require_lru_cache();
    var commandCache = new LRU({ max: 50, maxAge: 30 * 1e3 });
    function resolveCommand(command, noExtension) {
      var resolved;
      noExtension = !!noExtension;
      resolved = commandCache.get(command + "!" + noExtension);
      if (commandCache.has(command)) {
        return commandCache.get(command);
      }
      try {
        resolved = !noExtension ? which.sync(command) : which.sync(command, { pathExt: path.delimiter + (process.env.PATHEXT || "") });
      } catch (e) {
      }
      commandCache.set(command + "!" + noExtension, resolved);
      return resolved;
    }
    module2.exports = resolveCommand;
  }
});

// node_modules/cross-spawn/lib/util/hasEmptyArgumentBug.js
var require_hasEmptyArgumentBug = __commonJS({
  "node_modules/cross-spawn/lib/util/hasEmptyArgumentBug.js"(exports2, module2) {
    "use strict";
    function hasEmptyArgumentBug() {
      var nodeVer;
      if (process.platform !== "win32") {
        return false;
      }
      nodeVer = process.version.substr(1).split(".").map(function(num) {
        return parseInt(num, 10);
      });
      return nodeVer[0] === 0 && nodeVer[1] < 12;
    }
    module2.exports = hasEmptyArgumentBug();
  }
});

// node_modules/cross-spawn/lib/util/escapeArgument.js
var require_escapeArgument = __commonJS({
  "node_modules/cross-spawn/lib/util/escapeArgument.js"(exports2, module2) {
    "use strict";
    function escapeArgument(arg, quote) {
      arg = "" + arg;
      if (!quote) {
        arg = arg.replace(/([()%!^<>&|;,"'\s])/g, "^$1");
      } else {
        arg = arg.replace(/(\\*)"/g, '$1$1\\"');
        arg = arg.replace(/(\\*)$/, "$1$1");
        arg = '"' + arg + '"';
      }
      return arg;
    }
    module2.exports = escapeArgument;
  }
});

// node_modules/cross-spawn/lib/util/escapeCommand.js
var require_escapeCommand = __commonJS({
  "node_modules/cross-spawn/lib/util/escapeCommand.js"(exports2, module2) {
    "use strict";
    var escapeArgument = require_escapeArgument();
    function escapeCommand(command) {
      return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArgument(command, true);
    }
    module2.exports = escapeCommand;
  }
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "node_modules/shebang-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /^#!.*/;
  }
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "node_modules/shebang-command/index.js"(exports2, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = function(str) {
      var match = str.match(shebangRegex);
      if (!match) {
        return null;
      }
      var arr = match[0].replace(/#! ?/, "").split(" ");
      var bin = arr[0].split("/").pop();
      var arg = arr[1];
      return bin === "env" ? arg : bin + (arg ? " " + arg : "");
    };
  }
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var LRU = require_lru_cache();
    var shebangCommand = require_shebang_command();
    var shebangCache = new LRU({ max: 50, maxAge: 30 * 1e3 });
    function readShebang(command) {
      var buffer;
      var fd;
      var shebang;
      if (shebangCache.has(command)) {
        return shebangCache.get(command);
      }
      buffer = new Buffer(150);
      try {
        fd = fs.openSync(command, "r");
        fs.readSync(fd, buffer, 0, 150, 0);
        fs.closeSync(fd);
      } catch (e) {
      }
      shebang = shebangCommand(buffer.toString());
      shebangCache.set(command, shebang);
      return shebang;
    }
    module2.exports = readShebang;
  }
});

// node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
    "use strict";
    var resolveCommand = require_resolveCommand();
    var hasEmptyArgumentBug = require_hasEmptyArgumentBug();
    var escapeArgument = require_escapeArgument();
    var escapeCommand = require_escapeCommand();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var skipShellRegExp = /\.(?:com|exe)$/i;
    var supportsShellOption = parseInt(process.version.substr(1).split(".")[0], 10) >= 6 || parseInt(process.version.substr(1).split(".")[0], 10) === 4 && parseInt(process.version.substr(1).split(".")[1], 10) >= 8;
    function parseNonShell(parsed) {
      var shebang;
      var needsShell;
      var applyQuotes;
      if (!isWin) {
        return parsed;
      }
      parsed.file = resolveCommand(parsed.command);
      parsed.file = parsed.file || resolveCommand(parsed.command, true);
      shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(resolveCommand(shebang) || resolveCommand(shebang, true));
      } else {
        needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(parsed.file);
      }
      if (needsShell) {
        applyQuotes = parsed.command !== "echo";
        parsed.command = escapeCommand(parsed.command);
        parsed.args = parsed.args.map(function(arg) {
          return escapeArgument(arg, applyQuotes);
        });
        parsed.args = ["/d", "/s", "/c", '"' + parsed.command + (parsed.args.length ? " " + parsed.args.join(" ") : "") + '"'];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parseShell(parsed) {
      var shellCommand;
      if (supportsShellOption) {
        return parsed;
      }
      shellCommand = [parsed.command].concat(parsed.args).join(" ");
      if (isWin) {
        parsed.command = typeof parsed.options.shell === "string" ? parsed.options.shell : process.env.comspec || "cmd.exe";
        parsed.args = ["/d", "/s", "/c", '"' + shellCommand + '"'];
        parsed.options.windowsVerbatimArguments = true;
      } else {
        if (typeof parsed.options.shell === "string") {
          parsed.command = parsed.options.shell;
        } else if (process.platform === "android") {
          parsed.command = "/system/bin/sh";
        } else {
          parsed.command = "/bin/sh";
        }
        parsed.args = ["-c", shellCommand];
      }
      return parsed;
    }
    function parse(command, args, options) {
      var parsed;
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = options || {};
      parsed = {
        command,
        args,
        options,
        file: void 0,
        original: command
      };
      return options.shell ? parseShell(parsed) : parseNonShell(parsed);
    }
    module2.exports = parse;
  }
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    var resolveCommand = require_resolveCommand();
    var isNode10 = process.version.indexOf("v0.10.") === 0;
    function notFoundError(command, syscall) {
      var err;
      err = new Error(syscall + " " + command + " ENOENT");
      err.code = err.errno = "ENOENT";
      err.syscall = syscall + " " + command;
      return err;
    }
    function hookChildProcess(cp, parsed) {
      var originalEmit;
      if (!isWin) {
        return;
      }
      originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        var err;
        if (name === "exit") {
          err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      if (isNode10 && status === -1) {
        parsed.file = isWin ? parsed.file : resolveCommand(parsed.original);
        if (!parsed.file) {
          return notFoundError(parsed.original, "spawnSync");
        }
      }
      return null;
    }
    module2.exports.hookChildProcess = hookChildProcess;
    module2.exports.verifyENOENT = verifyENOENT;
    module2.exports.verifyENOENTSync = verifyENOENTSync;
    module2.exports.notFoundError = notFoundError;
  }
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "node_modules/cross-spawn/index.js"(exports2, module2) {
    "use strict";
    var cp = require("child_process");
    var parse = require_parse();
    var enoent = require_enoent();
    var cpSpawnSync = cp.spawnSync;
    function spawn(command, args, options) {
      var parsed;
      var spawned;
      parsed = parse(command, args, options);
      spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      var parsed;
      var result;
      if (!cpSpawnSync) {
        try {
          cpSpawnSync = require("spawn-sync");
        } catch (ex) {
          throw new Error(
            "In order to use spawnSync on node 0.10 or older, you must install spawn-sync:\n\n  npm install spawn-sync --save"
          );
        }
      }
      parsed = parse(command, args, options);
      result = cpSpawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse;
    module2.exports._enoent = enoent;
  }
});

// node_modules/strip-eof/index.js
var require_strip_eof = __commonJS({
  "node_modules/strip-eof/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(x) {
      var lf = typeof x === "string" ? "\n" : "\n".charCodeAt();
      var cr = typeof x === "string" ? "\r" : "\r".charCodeAt();
      if (x[x.length - 1] === lf) {
        x = x.slice(0, x.length - 1);
      }
      if (x[x.length - 1] === cr) {
        x = x.slice(0, x.length - 1);
      }
      return x;
    };
  }
});

// node_modules/path-key/index.js
var require_path_key = __commonJS({
  "node_modules/path-key/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (opts) => {
      opts = opts || {};
      const env = opts.env || process.env;
      const platform = opts.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(env).find((x) => x.toUpperCase() === "PATH") || "Path";
    };
  }
});

// node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS({
  "node_modules/npm-run-path/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var pathKey = require_path_key();
    module2.exports = (opts) => {
      opts = Object.assign({
        cwd: process.cwd(),
        path: process.env[pathKey()]
      }, opts);
      let prev;
      let pth = path.resolve(opts.cwd);
      const ret = [];
      while (prev !== pth) {
        ret.push(path.join(pth, "node_modules/.bin"));
        prev = pth;
        pth = path.resolve(pth, "..");
      }
      ret.push(path.dirname(process.execPath));
      return ret.concat(opts.path).join(path.delimiter);
    };
    module2.exports.env = (opts) => {
      opts = Object.assign({
        env: process.env
      }, opts);
      const env = Object.assign({}, opts.env);
      const path2 = pathKey({ env });
      opts.path = env[path2];
      env[path2] = module2.exports(opts);
      return env;
    };
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream = module2.exports = function(stream) {
      return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    };
    isStream.writable = function(stream) {
      return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    };
    isStream.readable = function(stream) {
      return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    };
    isStream.duplex = function(stream) {
      return isStream.writable(stream) && isStream.readable(stream);
    };
    isStream.transform = function(stream) {
      return isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
    };
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var PassThrough = require("stream").PassThrough;
    module2.exports = (opts) => {
      opts = Object.assign({}, opts);
      const array = opts.array;
      let encoding = opts.encoding;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      let len = 0;
      const ret = [];
      const stream = new PassThrough({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      stream.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream.getBufferedLength = () => len;
      return stream;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var bufferStream = require_buffer_stream();
    function getStream(inputStream, opts) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      opts = Object.assign({ maxBuffer: Infinity }, opts);
      const maxBuffer = opts.maxBuffer;
      let stream;
      let clean;
      const p = new Promise((resolve, reject) => {
        const error = (err) => {
          if (err) {
            err.bufferedData = stream.getBufferedValue();
          }
          reject(err);
        };
        stream = bufferStream(opts);
        inputStream.once("error", error);
        inputStream.pipe(stream);
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            reject(new Error("maxBuffer exceeded"));
          }
        });
        stream.once("error", error);
        stream.on("end", resolve);
        clean = () => {
          if (inputStream.unpipe) {
            inputStream.unpipe(stream);
          }
        };
      });
      p.then(clean, clean);
      return p.then(() => stream.getBufferedValue());
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream, opts) => getStream(stream, Object.assign({}, opts, { encoding: "buffer" }));
    module2.exports.array = (stream, opts) => getStream(stream, Object.assign({}, opts, { array: true }));
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/signals.js"(exports2, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/signal-exit/index.js"(exports2, module2) {
    var process2 = global.process;
    var processOk = function(process3) {
      return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    };
    if (!processOk(process2)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert = require("assert");
      signals = require_signals();
      isWin = /^win/i.test(process2.platform);
      EE = require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process2.__signal_exit_emitter__) {
        emitter = process2.__signal_exit_emitter__;
      } else {
        emitter = process2.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process2.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process2.emit = originalProcessEmit;
        process2.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process2.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process2.kill(process2.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process2.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process2.emit = processEmit;
        process2.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process2.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process2.exitCode = code || /* istanbul ignore next */
        0;
        emit("exit", process2.exitCode, null);
        emit("afterexit", process2.exitCode, null);
        originalProcessReallyExit.call(process2, process2.exitCode);
      };
      originalProcessEmit = process2.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process2.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process2.exitCode, null);
          emit("afterexit", process2.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/execa/lib/errname.js
var require_errname = __commonJS({
  "node_modules/execa/lib/errname.js"(exports2, module2) {
    "use strict";
    var uv;
    try {
      uv = process.binding("uv");
      if (typeof uv.errname !== "function") {
        throw new TypeError("uv.errname is not a function");
      }
    } catch (err) {
      console.error("execa/lib/errname: unable to establish process.binding('uv')", err);
      uv = null;
    }
    function errname(uv2, code) {
      if (uv2) {
        return uv2.errname(code);
      }
      if (!(code < 0)) {
        throw new Error("err >= 0");
      }
      return `Unknown system error ${code}`;
    }
    module2.exports = (code) => errname(uv, code);
    module2.exports.__test__ = errname;
  }
});

// node_modules/execa/lib/stdio.js
var require_stdio = __commonJS({
  "node_modules/execa/lib/stdio.js"(exports2, module2) {
    "use strict";
    var alias = ["stdin", "stdout", "stderr"];
    var hasAlias = (opts) => alias.some((x) => Boolean(opts[x]));
    module2.exports = (opts) => {
      if (!opts) {
        return null;
      }
      if (opts.stdio && hasAlias(opts)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${alias.map((x) => `\`${x}\``).join(", ")}`);
      }
      if (typeof opts.stdio === "string") {
        return opts.stdio;
      }
      const stdio = opts.stdio || [];
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const result = [];
      const len = Math.max(stdio.length, alias.length);
      for (let i = 0; i < len; i++) {
        let value = null;
        if (stdio[i] !== void 0) {
          value = stdio[i];
        } else if (opts[alias[i]] !== void 0) {
          value = opts[alias[i]];
        }
        result[i] = value;
      }
      return result;
    };
  }
});

// node_modules/execa/index.js
var require_execa = __commonJS({
  "node_modules/execa/index.js"(exports2, module2) {
    "use strict";
    var childProcess = require("child_process");
    var util = require("util");
    var crossSpawn = require_cross_spawn();
    var stripEof = require_strip_eof();
    var npmRunPath = require_npm_run_path();
    var isStream = require_is_stream();
    var _getStream = require_get_stream();
    var pFinally = require_p_finally();
    var onExit = require_signal_exit();
    var errname = require_errname();
    var stdio = require_stdio();
    var TEN_MEGABYTES = 1e3 * 1e3 * 10;
    function handleArgs(cmd, args, opts) {
      let parsed;
      if (opts && opts.env && opts.extendEnv !== false) {
        opts.env = Object.assign({}, process.env, opts.env);
      }
      if (opts && opts.__winShell === true) {
        delete opts.__winShell;
        parsed = {
          command: cmd,
          args,
          options: opts,
          file: cmd,
          original: cmd
        };
      } else {
        parsed = crossSpawn._parse(cmd, args, opts);
      }
      opts = Object.assign({
        maxBuffer: TEN_MEGABYTES,
        stripEof: true,
        preferLocal: true,
        localDir: parsed.options.cwd || process.cwd(),
        encoding: "utf8",
        reject: true,
        cleanup: true
      }, parsed.options);
      opts.stdio = stdio(opts);
      if (opts.preferLocal) {
        opts.env = npmRunPath.env(Object.assign({}, opts, { cwd: opts.localDir }));
      }
      return {
        cmd: parsed.command,
        args: parsed.args,
        opts,
        parsed
      };
    }
    function handleInput(spawned, opts) {
      const input = opts.input;
      if (input === null || input === void 0) {
        return;
      }
      if (isStream(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    }
    function handleOutput(opts, val) {
      if (val && opts.stripEof) {
        val = stripEof(val);
      }
      return val;
    }
    function handleShell(fn, cmd, opts) {
      let file = "/bin/sh";
      let args = ["-c", cmd];
      opts = Object.assign({}, opts);
      if (process.platform === "win32") {
        opts.__winShell = true;
        file = process.env.comspec || "cmd.exe";
        args = ["/s", "/c", `"${cmd}"`];
        opts.windowsVerbatimArguments = true;
      }
      if (opts.shell) {
        file = opts.shell;
        delete opts.shell;
      }
      return fn(file, args, opts);
    }
    function getStream(process2, stream, encoding, maxBuffer) {
      if (!process2[stream]) {
        return null;
      }
      let ret;
      if (encoding) {
        ret = _getStream(process2[stream], {
          encoding,
          maxBuffer
        });
      } else {
        ret = _getStream.buffer(process2[stream], { maxBuffer });
      }
      return ret.catch((err) => {
        err.stream = stream;
        err.message = `${stream} ${err.message}`;
        throw err;
      });
    }
    module2.exports = (cmd, args, opts) => {
      let joinedCmd = cmd;
      if (Array.isArray(args) && args.length > 0) {
        joinedCmd += " " + args.join(" ");
      }
      const parsed = handleArgs(cmd, args, opts);
      const encoding = parsed.opts.encoding;
      const maxBuffer = parsed.opts.maxBuffer;
      let spawned;
      try {
        spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
      } catch (err) {
        return Promise.reject(err);
      }
      let removeExitHandler;
      if (parsed.opts.cleanup) {
        removeExitHandler = onExit(() => {
          spawned.kill();
        });
      }
      let timeoutId = null;
      let timedOut = false;
      const cleanupTimeout = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      if (parsed.opts.timeout > 0) {
        timeoutId = setTimeout(() => {
          timeoutId = null;
          timedOut = true;
          spawned.kill(parsed.opts.killSignal);
        }, parsed.opts.timeout);
      }
      const processDone = new Promise((resolve) => {
        spawned.on("exit", (code, signal) => {
          cleanupTimeout();
          resolve({ code, signal });
        });
        spawned.on("error", (err) => {
          cleanupTimeout();
          resolve({ err });
        });
        if (spawned.stdin) {
          spawned.stdin.on("error", (err) => {
            cleanupTimeout();
            resolve({ err });
          });
        }
      });
      function destroy() {
        if (spawned.stdout) {
          spawned.stdout.destroy();
        }
        if (spawned.stderr) {
          spawned.stderr.destroy();
        }
      }
      const promise = pFinally(Promise.all([
        processDone,
        getStream(spawned, "stdout", encoding, maxBuffer),
        getStream(spawned, "stderr", encoding, maxBuffer)
      ]).then((arr) => {
        const result = arr[0];
        const stdout = arr[1];
        const stderr = arr[2];
        let err = result.err;
        const code = result.code;
        const signal = result.signal;
        if (removeExitHandler) {
          removeExitHandler();
        }
        if (err || code !== 0 || signal !== null) {
          if (!err) {
            let output = "";
            if (Array.isArray(parsed.opts.stdio)) {
              if (parsed.opts.stdio[2] !== "inherit") {
                output += output.length > 0 ? stderr : `
${stderr}`;
              }
              if (parsed.opts.stdio[1] !== "inherit") {
                output += `
${stdout}`;
              }
            } else if (parsed.opts.stdio !== "inherit") {
              output = `
${stderr}${stdout}`;
            }
            err = new Error(`Command failed: ${joinedCmd}${output}`);
            err.code = code < 0 ? errname(code) : code;
          }
          err.killed = err.killed || spawned.killed;
          err.stdout = stdout;
          err.stderr = stderr;
          err.failed = true;
          err.signal = signal || null;
          err.cmd = joinedCmd;
          err.timedOut = timedOut;
          if (!parsed.opts.reject) {
            return err;
          }
          throw err;
        }
        return {
          stdout: handleOutput(parsed.opts, stdout),
          stderr: handleOutput(parsed.opts, stderr),
          code: 0,
          failed: false,
          killed: false,
          signal: null,
          cmd: joinedCmd,
          timedOut: false
        };
      }), destroy);
      crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);
      handleInput(spawned, parsed.opts);
      spawned.then = promise.then.bind(promise);
      spawned.catch = promise.catch.bind(promise);
      return spawned;
    };
    module2.exports.stdout = function() {
      return module2.exports.apply(null, arguments).then((x) => x.stdout);
    };
    module2.exports.stderr = function() {
      return module2.exports.apply(null, arguments).then((x) => x.stderr);
    };
    module2.exports.shell = (cmd, opts) => handleShell(module2.exports, cmd, opts);
    module2.exports.sync = (cmd, args, opts) => {
      const parsed = handleArgs(cmd, args, opts);
      if (isStream(parsed.opts.input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
      const result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);
      if (result.error || result.status !== 0) {
        throw result.error || new Error(result.stderr === "" ? result.stdout : result.stderr);
      }
      result.stdout = handleOutput(parsed.opts, result.stdout);
      result.stderr = handleOutput(parsed.opts, result.stderr);
      return result;
    };
    module2.exports.shellSync = (cmd, opts) => handleShell(module2.exports.sync, cmd, opts);
    module2.exports.spawn = util.deprecate(module2.exports, "execa.spawn() is deprecated. Use execa() instead.");
  }
});

// node_modules/invert-kv/index.js
var require_invert_kv = __commonJS({
  "node_modules/invert-kv/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(obj) {
      if (typeof obj !== "object") {
        throw new TypeError("Expected an object");
      }
      var ret = {};
      for (var key in obj) {
        var val = obj[key];
        ret[val] = key;
      }
      return ret;
    };
  }
});

// node_modules/lcid/lcid.json
var require_lcid = __commonJS({
  "node_modules/lcid/lcid.json"(exports2, module2) {
    module2.exports = {
      af_ZA: 1078,
      am_ET: 1118,
      ar_AE: 14337,
      ar_BH: 15361,
      ar_DZ: 5121,
      ar_EG: 3073,
      ar_IQ: 2049,
      ar_JO: 11265,
      ar_KW: 13313,
      ar_LB: 12289,
      ar_LY: 4097,
      ar_MA: 6145,
      ar_OM: 8193,
      ar_QA: 16385,
      ar_SA: 1025,
      ar_SY: 10241,
      ar_TN: 7169,
      ar_YE: 9217,
      arn_CL: 1146,
      as_IN: 1101,
      az_AZ: 2092,
      ba_RU: 1133,
      be_BY: 1059,
      bg_BG: 1026,
      bn_IN: 1093,
      bo_BT: 2129,
      bo_CN: 1105,
      br_FR: 1150,
      bs_BA: 8218,
      ca_ES: 1027,
      co_FR: 1155,
      cs_CZ: 1029,
      cy_GB: 1106,
      da_DK: 1030,
      de_AT: 3079,
      de_CH: 2055,
      de_DE: 1031,
      de_LI: 5127,
      de_LU: 4103,
      div_MV: 1125,
      dsb_DE: 2094,
      el_GR: 1032,
      en_AU: 3081,
      en_BZ: 10249,
      en_CA: 4105,
      en_CB: 9225,
      en_GB: 2057,
      en_IE: 6153,
      en_IN: 18441,
      en_JA: 8201,
      en_MY: 17417,
      en_NZ: 5129,
      en_PH: 13321,
      en_TT: 11273,
      en_US: 1033,
      en_ZA: 7177,
      en_ZW: 12297,
      es_AR: 11274,
      es_BO: 16394,
      es_CL: 13322,
      es_CO: 9226,
      es_CR: 5130,
      es_DO: 7178,
      es_EC: 12298,
      es_ES: 3082,
      es_GT: 4106,
      es_HN: 18442,
      es_MX: 2058,
      es_NI: 19466,
      es_PA: 6154,
      es_PE: 10250,
      es_PR: 20490,
      es_PY: 15370,
      es_SV: 17418,
      es_UR: 14346,
      es_US: 21514,
      es_VE: 8202,
      et_EE: 1061,
      eu_ES: 1069,
      fa_IR: 1065,
      fi_FI: 1035,
      fil_PH: 1124,
      fo_FO: 1080,
      fr_BE: 2060,
      fr_CA: 3084,
      fr_CH: 4108,
      fr_FR: 1036,
      fr_LU: 5132,
      fr_MC: 6156,
      fy_NL: 1122,
      ga_IE: 2108,
      gbz_AF: 1164,
      gl_ES: 1110,
      gsw_FR: 1156,
      gu_IN: 1095,
      ha_NG: 1128,
      he_IL: 1037,
      hi_IN: 1081,
      hr_BA: 4122,
      hr_HR: 1050,
      hu_HU: 1038,
      hy_AM: 1067,
      id_ID: 1057,
      ii_CN: 1144,
      is_IS: 1039,
      it_CH: 2064,
      it_IT: 1040,
      iu_CA: 2141,
      ja_JP: 1041,
      ka_GE: 1079,
      kh_KH: 1107,
      kk_KZ: 1087,
      kl_GL: 1135,
      kn_IN: 1099,
      ko_KR: 1042,
      kok_IN: 1111,
      ky_KG: 1088,
      lb_LU: 1134,
      lo_LA: 1108,
      lt_LT: 1063,
      lv_LV: 1062,
      mi_NZ: 1153,
      mk_MK: 1071,
      ml_IN: 1100,
      mn_CN: 2128,
      mn_MN: 1104,
      moh_CA: 1148,
      mr_IN: 1102,
      ms_BN: 2110,
      ms_MY: 1086,
      mt_MT: 1082,
      my_MM: 1109,
      nb_NO: 1044,
      ne_NP: 1121,
      nl_BE: 2067,
      nl_NL: 1043,
      nn_NO: 2068,
      ns_ZA: 1132,
      oc_FR: 1154,
      or_IN: 1096,
      pa_IN: 1094,
      pl_PL: 1045,
      ps_AF: 1123,
      pt_BR: 1046,
      pt_PT: 2070,
      qut_GT: 1158,
      quz_BO: 1131,
      quz_EC: 2155,
      quz_PE: 3179,
      rm_CH: 1047,
      ro_RO: 1048,
      ru_RU: 1049,
      rw_RW: 1159,
      sa_IN: 1103,
      sah_RU: 1157,
      se_FI: 3131,
      se_NO: 1083,
      se_SE: 2107,
      si_LK: 1115,
      sk_SK: 1051,
      sl_SI: 1060,
      sma_NO: 6203,
      sma_SE: 7227,
      smj_NO: 4155,
      smj_SE: 5179,
      smn_FI: 9275,
      sms_FI: 8251,
      sq_AL: 1052,
      sr_BA: 7194,
      sr_SP: 3098,
      sv_FI: 2077,
      sv_SE: 1053,
      sw_KE: 1089,
      syr_SY: 1114,
      ta_IN: 1097,
      te_IN: 1098,
      tg_TJ: 1064,
      th_TH: 1054,
      tk_TM: 1090,
      tmz_DZ: 2143,
      tn_ZA: 1074,
      tr_TR: 1055,
      tt_RU: 1092,
      ug_CN: 1152,
      uk_UA: 1058,
      ur_IN: 2080,
      ur_PK: 1056,
      uz_UZ: 2115,
      vi_VN: 1066,
      wen_DE: 1070,
      wo_SN: 1160,
      xh_ZA: 1076,
      yo_NG: 1130,
      zh_CHS: 4,
      zh_CHT: 31748,
      zh_CN: 2052,
      zh_HK: 3076,
      zh_MO: 5124,
      zh_SG: 4100,
      zh_TW: 1028,
      zu_ZA: 1077
    };
  }
});

// node_modules/lcid/index.js
var require_lcid2 = __commonJS({
  "node_modules/lcid/index.js"(exports2) {
    "use strict";
    var invertKv = require_invert_kv();
    var all = require_lcid();
    var inverted = invertKv(all);
    exports2.from = function(lcidCode) {
      if (typeof lcidCode !== "number") {
        throw new TypeError("Expected a number");
      }
      return inverted[lcidCode];
    };
    exports2.to = function(localeId) {
      if (typeof localeId !== "string") {
        throw new TypeError("Expected a string");
      }
      return all[localeId];
    };
    exports2.all = all;
  }
});

// node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "node_modules/mimic-fn/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (to, from) => {
      for (const prop of Object.getOwnPropertyNames(from).concat(Object.getOwnPropertySymbols(from))) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to;
    };
  }
});

// node_modules/mem/index.js
var require_mem = __commonJS({
  "node_modules/mem/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = require_mimic_fn();
    var cacheStore = /* @__PURE__ */ new WeakMap();
    var defaultCacheKey = function(x) {
      if (arguments.length === 1 && (x === null || x === void 0 || typeof x !== "function" && typeof x !== "object")) {
        return x;
      }
      return JSON.stringify(arguments);
    };
    module2.exports = (fn, opts) => {
      opts = Object.assign({
        cacheKey: defaultCacheKey,
        cache: /* @__PURE__ */ new Map()
      }, opts);
      const memoized = function() {
        const cache = cacheStore.get(memoized);
        const key = opts.cacheKey.apply(null, arguments);
        if (cache.has(key)) {
          const c = cache.get(key);
          if (typeof opts.maxAge !== "number" || Date.now() < c.maxAge) {
            return c.data;
          }
        }
        const ret = fn.apply(null, arguments);
        cache.set(key, {
          data: ret,
          maxAge: Date.now() + (opts.maxAge || 0)
        });
        return ret;
      };
      mimicFn(memoized, fn);
      cacheStore.set(memoized, opts.cache);
      return memoized;
    };
    module2.exports.clear = (fn) => {
      const cache = cacheStore.get(fn);
      if (cache && typeof cache.clear === "function") {
        cache.clear();
      }
    };
  }
});

// node_modules/os-locale/index.js
var require_os_locale = __commonJS({
  "node_modules/os-locale/index.js"(exports2, module2) {
    "use strict";
    var execa = require_execa();
    var lcid = require_lcid2();
    var mem = require_mem();
    var defaultOpts = { spawn: true };
    var defaultLocale = "en_US";
    function getEnvLocale(env) {
      env = env || process.env;
      return env.LC_ALL || env.LC_MESSAGES || env.LANG || env.LANGUAGE;
    }
    function parseLocale(x) {
      const env = x.split("\n").reduce((env2, def) => {
        def = def.split("=");
        env2[def[0]] = def[1].replace(/^"|"$/g, "");
        return env2;
      }, {});
      return getEnvLocale(env);
    }
    function getLocale(str) {
      return str && str.replace(/[.:].*/, "");
    }
    function getAppleLocale() {
      return execa.stdout("defaults", ["read", "-g", "AppleLocale"]);
    }
    function getAppleLocaleSync() {
      return execa.sync("defaults", ["read", "-g", "AppleLocale"]).stdout;
    }
    function getUnixLocale() {
      if (process.platform === "darwin") {
        return getAppleLocale();
      }
      return execa.stdout("locale").then((stdout) => getLocale(parseLocale(stdout)));
    }
    function getUnixLocaleSync() {
      if (process.platform === "darwin") {
        return getAppleLocaleSync();
      }
      return getLocale(parseLocale(execa.sync("locale").stdout));
    }
    function getWinLocale() {
      return execa.stdout("wmic", ["os", "get", "locale"]).then((stdout) => {
        const lcidCode = parseInt(stdout.replace("Locale", ""), 16);
        return lcid.from(lcidCode);
      });
    }
    function getWinLocaleSync() {
      const stdout = execa.sync("wmic", ["os", "get", "locale"]).stdout;
      const lcidCode = parseInt(stdout.replace("Locale", ""), 16);
      return lcid.from(lcidCode);
    }
    module2.exports = mem((opts) => {
      opts = opts || defaultOpts;
      const envLocale = getEnvLocale();
      let thenable;
      if (envLocale || opts.spawn === false) {
        thenable = Promise.resolve(getLocale(envLocale));
      } else if (process.platform === "win32") {
        thenable = getWinLocale();
      } else {
        thenable = getUnixLocale();
      }
      return thenable.then((locale) => locale || defaultLocale).catch(() => defaultLocale);
    });
    module2.exports.sync = mem((opts) => {
      opts = opts || defaultOpts;
      const envLocale = getEnvLocale();
      let res;
      if (envLocale || opts.spawn === false) {
        res = getLocale(envLocale);
      } else {
        try {
          if (process.platform === "win32") {
            res = getWinLocaleSync();
          } else {
            res = getUnixLocaleSync();
          }
        } catch (err) {
        }
      }
      return res || defaultLocale;
    });
  }
});

// node_modules/isomorphic-language/node.js
var require_node = __commonJS({
  "node_modules/isomorphic-language/node.js"(exports2, module2) {
    var locale = require_os_locale();
    module2.exports = locale.sync.bind(locale);
  }
});

// node_modules/tiny-i18n/index.es5.js
var require_index_es5 = __commonJS({
  "node_modules/tiny-i18n/index.es5.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    exports2.createIsolateI18n = createIsolateI18n2;
    var _isomorphicLanguage = require_node();
    var _isomorphicLanguage2 = _interopRequireDefault(_isomorphicLanguage);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createIsolateI18n2() {
      var database = {};
      var currLanguage = ((0, _isomorphicLanguage2.default)() || "").toLowerCase();
      function assertDictionary(language) {
        if (!getDictionary(language)) {
          throw new Error("[tiny-i18n] Error: the dictionary of language: " + language + " is not existed.");
        }
      }
      function getCurrentLanguage() {
        return currLanguage.toLowerCase();
      }
      function getLanguages() {
        return Object.keys(database);
      }
      function getDictionary() {
        var language = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getCurrentLanguage();
        return database[language.toLowerCase()];
      }
      function getWord(key) {
        var language = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentLanguage();
        assertDictionary(language);
        var dictionary = getDictionary(language);
        return dictionary[key];
      }
      function setDictionary(dict) {
        var language = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentLanguage();
        language = language.toLowerCase();
        database[language] = dict;
        return database[language];
      }
      function extendDictionary(dict) {
        var language = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentLanguage();
        language = language.toLowerCase();
        return setDictionary(_extends({}, getDictionary(language), dict), language);
      }
      function setLanguage(language) {
        currLanguage = language;
      }
      function i18n(key) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var current = getCurrentLanguage();
        assertDictionary(current);
        var value = getWord(key, current);
        if (typeof value !== "string") {
          process.env.NODE_ENV !== "production" && console.error("[tiny-i18n] Error: the `" + key + "` word is not found in " + current + " language.");
          return "{{" + key + "}}";
        }
        return value.replace(/\${(\d+)}/g, function(_, $1) {
          return args[parseInt($1) - 1];
        });
      }
      return {
        i18n,
        setDictionary,
        setLanguage,
        getDataBase: function getDataBase() {
          return database;
        },
        getCurrentLanguage,
        getDictionary,
        getLanguages,
        getWord,
        extendDictionary
      };
    }
    var tinyI18nInstance = createIsolateI18n2();
    var tinyI18n2 = Object.assign({ createIsolateI18n: createIsolateI18n2 }, tinyI18nInstance);
    exports2.default = tinyI18n2;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HabitButtonPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/i18n.ts
var import_tiny_i18n = __toESM(require_index_es5());

// src/locales/en.json
var en_default = {
  "app.heading": "Habit Button",
  "app.description": "Track habits with a one-click button and heatmap.",
  "settings.heading": "Habit Button",
  "settings.language.label": "Interface language",
  "settings.language.desc": "Language for plugin UI.",
  "settings.language.options.auto": "Auto",
  "settings.language.options.en": "English",
  "settings.language.options.ru": "Russian",
  "settings.dailyFolder.label": "Daily folder",
  "settings.dailyFolder.desc": "Folder that contains daily notes to scan for habits.",
  "settings.templatePath.label": "Daily note template",
  "settings.templatePath.desc": "Optional template used when creating a missing daily note.",
  "settings.defaultLayout.label": "Default layout",
  "settings.defaultLayout.desc": "Heatmap layout to use when none is specified.",
  "settings.defaultLayout.options.grid": "Grid",
  "settings.defaultLayout.options.row": "Row",
  "settings.gridWeeks.label": "Grid weeks",
  "settings.gridWeeks.desc": "Number of weeks to show in grid heatmap layout.",
  "settings.rowDays.label": "Row days",
  "settings.rowDays.desc": "Number of days to show in row heatmap layout.",
  "commands.insertBlock": "Insert habit button block",
  "ui.errorNoTitle": "[habit-button] Title is required",
  "ui.noticeAdded": "Added: ${1}",
  "ui.noticeError": "Failed to record habit",
  "ui.markHabit": "Mark: ${1}",
  "meta.streak": "Streak: ${1} days",
  "meta.streakZero": "Streak: 0 days",
  "meta.justNow": "just now",
  "meta.minutesAgo": "${1}m ago",
  "meta.hoursAgo": "${1}h ago",
  "meta.daysAgo": "${1} d ago",
  "overdue.label": "<${1}h \u{1F525}",
  "snippet.title": "My habit",
  "snippet.heatLayoutComment": '# "grid" or "row"'
};

// src/locales/ru.json
var ru_default = {
  "app.heading": "\u041A\u043D\u043E\u043F\u043A\u0430 \u043F\u0440\u0438\u0432\u044B\u0447\u043A\u0438",
  "app.description": "\u041E\u0442\u043C\u0435\u0447\u0430\u0439\u0442\u0435 \u043F\u0440\u0438\u0432\u044B\u0447\u043A\u0438 \u043E\u0434\u043D\u0438\u043C \u043A\u043B\u0438\u043A\u043E\u043C \u0438 \u0441\u043B\u0435\u0434\u0438\u0442\u0435 \u0437\u0430 \u0442\u0435\u043F\u043B\u043E\u0432\u043E\u0439 \u043A\u0430\u0440\u0442\u043E\u0439.",
  "settings.heading": "\u041A\u043D\u043E\u043F\u043A\u0430 \u043F\u0440\u0438\u0432\u044B\u0447\u043A\u0438",
  "settings.language.label": "\u042F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430",
  "settings.language.desc": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u044F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u043F\u043B\u0430\u0433\u0438\u043D\u0430.",
  "settings.language.options.auto": "\u0410\u0432\u0442\u043E",
  "settings.language.options.en": "\u0410\u043D\u0433\u043B\u0438\u0439\u0441\u043A\u0438\u0439",
  "settings.language.options.ru": "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
  "settings.dailyFolder.label": "\u041F\u0430\u043F\u043A\u0430 \u0441 \u0434\u044D\u0439\u043B\u0438",
  "settings.dailyFolder.desc": "\u041F\u0430\u043F\u043A\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0438\u0441\u043A\u0430\u0442\u044C \u0435\u0436\u0435\u0434\u043D\u0435\u0432\u043D\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438.",
  "settings.templatePath.label": "\u0428\u0430\u0431\u043B\u043E\u043D \u0435\u0436\u0435\u0434\u043D\u0435\u0432\u043D\u0438\u043A\u0430",
  "settings.templatePath.desc": "\u041D\u0435\u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u0448\u0430\u0431\u043B\u043E\u043D \u0434\u043B\u044F \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0435\u043C\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438.",
  "settings.defaultLayout.label": "\u0420\u0430\u0437\u043C\u0435\u0442\u043A\u0430 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
  "settings.defaultLayout.desc": "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0441\u044F, \u0435\u0441\u043B\u0438 \u0432 \u0431\u043B\u043E\u043A\u0435 \u043D\u0438\u0447\u0435\u0433\u043E \u043D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D\u043E.",
  "settings.defaultLayout.options.grid": "\u0421\u0435\u0442\u043A\u0430",
  "settings.defaultLayout.options.row": "\u041B\u0435\u043D\u0442\u0430",
  "settings.gridWeeks.label": "\u041D\u0435\u0434\u0435\u043B\u0438 \u0432 \u0441\u0435\u0442\u043A\u0435",
  "settings.gridWeeks.desc": "\u0421\u043A\u043E\u043B\u044C\u043A\u043E \u043D\u0435\u0434\u0435\u043B\u044C \u043F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0432 \u0442\u0435\u043F\u043B\u043E\u0432\u043E\u0439 \u043A\u0430\u0440\u0442\u0435-\u0441\u0435\u0442\u043A\u0435.",
  "settings.rowDays.label": "\u0414\u043D\u0438 \u0432 \u043B\u0435\u043D\u0442\u0435",
  "settings.rowDays.desc": "\u0421\u043A\u043E\u043B\u044C\u043A\u043E \u0434\u043D\u0435\u0439 \u043F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0432 \u0442\u0435\u043F\u043B\u043E\u0432\u043E\u0439 \u043B\u0435\u043D\u0442\u0435.",
  "commands.insertBlock": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0431\u043B\u043E\u043A Habit Button",
  "ui.errorNoTitle": "[habit-button] \u041D\u0435 \u0437\u0430\u0434\u0430\u043D title",
  "ui.noticeAdded": "\u0414\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043E: ${1}",
  "ui.noticeError": "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0438\u0441\u0438 \u043F\u0440\u0438\u0432\u044B\u0447\u043A\u0438",
  "ui.markHabit": "\u041E\u0442\u043C\u0435\u0442\u0438\u0442\u044C: ${1}",
  "meta.streak": "\u0421\u0442\u0440\u0438\u043A: ${1} \u0434\u043D.",
  "meta.streakZero": "\u0421\u0442\u0440\u0438\u043A: 0 \u0434\u043D.",
  "meta.justNow": "\u0442\u043E\u043B\u044C\u043A\u043E \u0447\u0442\u043E",
  "meta.minutesAgo": "${1}\u043C \u043D\u0430\u0437\u0430\u0434",
  "meta.hoursAgo": "${1}\u0447 \u043D\u0430\u0437\u0430\u0434",
  "meta.daysAgo": "${1} \u0434\u043D. \u043D\u0430\u0437\u0430\u0434",
  "overdue.label": "<${1}\u0447. \u{1F525}",
  "snippet.title": "\u041C\u043E\u044F \u043F\u0440\u0438\u0432\u044B\u0447\u043A\u0430",
  "snippet.heatLayoutComment": '# "grid" \u0438\u043B\u0438 "row"'
};

// src/i18n.ts
var { createIsolateI18n } = import_tiny_i18n.default;
var instance = createIsolateI18n();
var dictionaries = {
  en: en_default,
  ru: ru_default
};
var FALLBACK_LOCALE = "en";
Object.entries(dictionaries).forEach(([locale, dict]) => {
  instance.setDictionary(dict, locale);
});
var currentLocale = FALLBACK_LOCALE;
instance.setLanguage(FALLBACK_LOCALE);
function normalizeLocale(locale) {
  if (!locale)
    return null;
  const normalized = locale.toLowerCase();
  if (normalized.startsWith("ru"))
    return "ru";
  if (normalized.startsWith("en"))
    return "en";
  return null;
}
function setResolvedLocale(locale) {
  currentLocale = locale;
  instance.setLanguage(locale);
}
function resolveLocale(preference, candidates) {
  if (preference !== "auto") {
    return normalizeLocale(preference) ?? FALLBACK_LOCALE;
  }
  for (const candidate of candidates) {
    const normalized = normalizeLocale(candidate);
    if (normalized)
      return normalized;
  }
  return FALLBACK_LOCALE;
}
function applyLocale(preference, candidates) {
  const locale = resolveLocale(preference, candidates);
  setResolvedLocale(locale);
  return locale;
}
function t(key, ...args) {
  const translated = instance.i18n(key, ...args.map(String));
  return translated ?? key;
}

// src/settings.ts
var DEFAULT_SETTINGS = {
  dailyFolder: "daily",
  defaultLayout: "grid",
  weeks: 26,
  days: 240,
  templatePath: "meta/templates/daily note template.md",
  locale: "auto"
};
var HabitButtonSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: t("settings.heading") });
    new import_obsidian.Setting(containerEl).setName(t("settings.language.label")).setDesc(t("settings.language.desc")).addDropdown(
      (dropdown) => dropdown.addOptions({
        auto: t("settings.language.options.auto"),
        en: t("settings.language.options.en"),
        ru: t("settings.language.options.ru")
      }).setValue(this.plugin.settings.locale).onChange(async (value) => {
        if (value === "auto" || value === "en" || value === "ru") {
          this.plugin.settings.locale = value;
          await this.plugin.saveSettings();
          this.plugin.refreshLocale();
          this.display();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName(t("settings.dailyFolder.label")).setDesc(t("settings.dailyFolder.desc")).addText(
      (text) => text.setPlaceholder("daily").setValue(this.plugin.settings.dailyFolder).onChange(async (value) => {
        this.plugin.settings.dailyFolder = value.trim() || "daily";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(t("settings.templatePath.label")).setDesc(t("settings.templatePath.desc")).addText(
      (text) => text.setPlaceholder("meta/templates/daily note template.md").setValue(this.plugin.settings.templatePath).onChange(async (value) => {
        this.plugin.settings.templatePath = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(t("settings.defaultLayout.label")).setDesc(t("settings.defaultLayout.desc")).addDropdown(
      (dropdown) => dropdown.addOptions({ grid: t("settings.defaultLayout.options.grid"), row: t("settings.defaultLayout.options.row") }).setValue(this.plugin.settings.defaultLayout).onChange(async (value) => {
        if (value === "grid" || value === "row") {
          this.plugin.settings.defaultLayout = value;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName(t("settings.gridWeeks.label")).setDesc(t("settings.gridWeeks.desc")).addSlider(
      (slider) => slider.setLimits(4, 52, 1).setValue(this.plugin.settings.weeks).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.weeks = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(t("settings.rowDays.label")).setDesc(t("settings.rowDays.desc")).addSlider(
      (slider) => slider.setLimits(30, 365, 5).setValue(this.plugin.settings.days).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.days = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// styles.css
var styles_default = '.dv-habit-card {\n  display: flex;\n  align-items: flex-start;\n  background: var(--background-primary);\n  border-radius: 16px;\n  transition: opacity 0.18s ease, background 0.18s ease, border-color 0.18s ease;\n}\n\n.dv-habit-card.is-done {\n  opacity: 0.5;\n}\n\n.dv-habit-iconbtn {\n  width: 70px;\n  height: 70px;\n  border-radius: 12px;\n  font-size: 42px;\n  line-height: 1;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  border: 1px solid var(--background-modifier-border);\n  background: var(--background-secondary);\n  cursor: pointer;\n  user-select: none;\n  transition: transform 0.06s ease, background 0.18s ease, border-color 0.18s ease, color 0.18s ease;\n}\n\n.dv-habit-iconbtn:active {\n  transform: scale(0.98);\n}\n\n.dv-habit-iconbtn.is-done {\n  background: #10b981;\n  border-color: #10b981;\n  color: #052e16;\n}\n\n.dv-habit-right {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n  min-width: 0;\n  flex: 1;\n  margin-left: 16px;\n}\n\n.dv-habit-title {\n  font-weight: 600;\n  line-height: 1.2;\n}\n\n.dv-habit-meta {\n  display: flex;\n  gap: 8px;\n  align-items: center;\n  font-size: 0.95em;\n}\n\n.dv-habit-meta .last {\n  color: var(--text-muted);\n}\n\n.dv-habit-meta .last.is-overdue {\n  color: #b45309;\n  font-weight: 600;\n}\n\n.dv-habit-meta .bullet {\n  opacity: 0.6;\n}\n\n.dv-habit-meta .streak {\n  color: #059669;\n  font-weight: 600;\n}\n\n.dv-habit-meta .streak.is-zero {\n  color: var(--text-muted);\n}\n\n.dv-habit-meta .streak .time-left {\n  color: #b45309;\n  font-weight: 600;\n}\n\n.dv-habit-heat-row {\n  --dot-size: var(--habit-dot-size, 8px);\n  --dot-gap: var(--habit-dot-gap, 4px);\n  display: flex;\n  align-items: center;\n  gap: var(--dot-gap);\n  overflow: hidden;\n}\n\n.dv-habit-dot {\n  width: var(--dot-size);\n  height: var(--dot-size);\n  border-radius: 999px;\n  background: var(--background-modifier-border);\n  flex: 0 0 var(--dot-size);\n}\n\n.dv-habit-heat-grid {\n  --cell-size: var(--habit-cell-size, 9px);\n  --cell-gap: var(--habit-cell-gap, 3px);\n  display: flex;\n  gap: var(--cell-gap);\n  overflow: auto;\n  align-items: flex-start;\n}\n\n.dv-habit-col {\n  display: flex;\n  flex-direction: column;\n  gap: var(--cell-gap);\n}\n\n.dv-habit-cell {\n  width: var(--cell-size);\n  height: var(--cell-size);\n  border-radius: 2px;\n  background: var(--background-modifier-border);\n  transition: opacity 0.12s ease;\n}\n\n.dv-habit-cell.is-future {\n  opacity: 0 !important;\n  background: transparent !important;\n  pointer-events: none;\n}\n\n.dot-l1 {\n  background: #aceebb !important;\n}\n\n.dot-l2 {\n  background: #4ac26b !important;\n}\n\n.dot-l3 {\n  background: #2da44e !important;\n}\n\n.dot-l4 {\n  background: #116329 !important;\n}\n\n.dv-habit-card,\n.dv-habit-card * {\n  list-style: none !important;\n}\n\n.dv-habit-card ul,\n.dv-habit-card ol {\n  margin: 0 !important;\n  padding: 0 !important;\n}\n\n.dv-habit-card li::marker {\n  content: "" !important;\n}\n';

// src/main.ts
var DEFAULT_DIMENSIONS = {
  cellSize: 9,
  cellGap: 3,
  dotSize: 8,
  dotGap: 4
};
function pad2(n) {
  return String(n).padStart(2, "0");
}
function normalizeWhitespace(value) {
  return value.trim().replace(/\s+/g, " ");
}
function capitalizeFirst(value) {
  if (!value)
    return value;
  return value[0].toUpperCase() + value.slice(1);
}
function escapeRegExp(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function toHabitKey(value) {
  const lower = value.toLowerCase();
  return lower.replace(/\s+/g, "_").replace(/[^a-z-0-9_]/gi, "").replace(/_+/g, "_").replace(/^_+|_+$/g, "");
}
function nowHHMM(now) {
  return `${pad2(now.getHours())}:${pad2(now.getMinutes())}`;
}
function parseYMD(name) {
  const match = /^(\d{4})-(\d{2})-(\d{2})$/.exec(name);
  if (!match)
    return null;
  return { y: Number(match[1]), mo: Number(match[2]), d: Number(match[3]) };
}
function makeLocalDate(y, mo, d, hh = 0, mm = 0) {
  return new Date(y, mo - 1, d, hh, mm, 0, 0);
}
function isoOf(y, mo, d) {
  return `${y}-${pad2(mo)}-${pad2(d)}`;
}
function today0() {
  const now = /* @__PURE__ */ new Date();
  now.setHours(0, 0, 0, 0);
  return now;
}
function humanAgoShort(ts) {
  if (!ts)
    return "\u2014";
  const diffMs = Date.now() - ts.getTime();
  const mins = Math.max(0, Math.floor(diffMs / 6e4));
  const days = Math.floor(mins / 1440);
  const hours = Math.floor(mins % 1440 / 60);
  const minutes = mins % 60;
  if (days === 0 && hours < 1) {
    return mins < 2 ? t("meta.justNow") : t("meta.minutesAgo", minutes);
  }
  if (days === 0) {
    return t("meta.hoursAgo", hours);
  }
  if (days < 2) {
    return t("meta.hoursAgo", days * 24 + hours);
  }
  return t("meta.daysAgo", days);
}
function computeStreakByDays(days, allowedGapMs) {
  if (!days.length)
    return 0;
  const now = Date.now();
  const last = days[days.length - 1];
  if (now - last.getTime() > allowedGapMs)
    return 0;
  let streak = 1;
  for (let i = days.length - 2; i >= 0; i--) {
    if (days[i + 1].getTime() - days[i].getTime() <= allowedGapMs)
      streak++;
    else
      break;
  }
  return streak;
}
function sortDatesAscending(list) {
  return Array.from(list).sort((a, b) => a.getTime() - b.getTime());
}
function ensureTrailingNewline(value) {
  if (!value.endsWith("\n"))
    return `${value}
`;
  return value;
}
function trimSlashes(path) {
  return path.replace(/^\/+|\/+$/g, "");
}
var HabitButtonPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.styleEl = null;
  }
  async onload() {
    await this.loadSettings();
    this.refreshLocale();
    this.registerMarkdownCodeBlockProcessor(
      "habit-button",
      (source, el, ctx) => this.renderHabitButton(source, el, ctx)
    );
    this.addCommand({
      id: "habit-button-insert-block",
      name: t("commands.insertBlock"),
      editorCallback: (editor) => {
        const cursor = editor.getCursor();
        const snippet = [
          "```habit-button",
          `title: ${t("snippet.title")}`,
          "heatLayout: grid",
          t("snippet.heatLayoutComment"),
          "```",
          ""
        ].join("\n");
        editor.replaceRange(snippet, cursor);
      }
    });
    this.addSettingTab(new HabitButtonSettingTab(this.app, this));
    this.injectStyles();
  }
  onunload() {
    this.disposeStyles();
  }
  injectStyles() {
    if (this.styleEl)
      return;
    const style = document.createElement("style");
    style.id = "habit-button-styles";
    style.textContent = styles_default;
    document.head.appendChild(style);
    this.styleEl = style;
    this.register(() => this.disposeStyles());
  }
  disposeStyles() {
    if (this.styleEl?.parentElement) {
      this.styleEl.parentElement.removeChild(this.styleEl);
    }
    this.styleEl = null;
  }
  refreshLocale() {
    const preference = this.settings.locale;
    const candidates = [
      preference === "auto" ? void 0 : preference,
      this.app?.vault?.getConfig?.("locale"),
      this.app?.locale,
      typeof navigator !== "undefined" ? navigator.language : void 0
    ];
    applyLocale(preference, candidates);
  }
  parseBlock(source) {
    const trimmed = source.trim();
    if (!trimmed)
      return {};
    try {
      const parsed = (0, import_obsidian2.parseYaml)(trimmed);
      if (typeof parsed === "object" && parsed)
        return parsed;
      return {};
    } catch (error) {
      console.warn("Habit Button: failed to parse block", error);
      return {};
    }
  }
  resolveOptions(raw) {
    const title = raw.title ? normalizeWhitespace(String(raw.title)) : "";
    if (!title)
      return null;
    const normalizedTitle = capitalizeFirst(title);
    const layout = raw.heatLayout === "row" ? "row" : raw.heatLayout === "grid" ? "grid" : this.settings.defaultLayout;
    const weeks = Number.isFinite(raw.weeks) ? Math.max(1, Number(raw.weeks)) : this.settings.weeks;
    const days = Number.isFinite(raw.days) ? Math.max(1, Number(raw.days)) : this.settings.days;
    const dailyFolder = raw.dailyFolder?.trim().length ? trimSlashes(raw.dailyFolder.trim()) : this.settings.dailyFolder;
    const templateCandidate = raw.templatePath?.trim() || this.settings.templatePath?.trim();
    const templatePath = templateCandidate ? templateCandidate : void 0;
    return {
      title,
      normalizedTitle,
      icon: raw.icon,
      warnHoursThreshold: typeof raw.warnHoursThreshold === "number" ? raw.warnHoursThreshold : void 0,
      dailyFolder,
      heatLayout: layout,
      weeks,
      days,
      cellSize: Number.isFinite(raw.cellSize) ? Number(raw.cellSize) : DEFAULT_DIMENSIONS.cellSize,
      cellGap: Number.isFinite(raw.cellGap) ? Number(raw.cellGap) : DEFAULT_DIMENSIONS.cellGap,
      dotSize: Number.isFinite(raw.dotSize) ? Number(raw.dotSize) : DEFAULT_DIMENSIONS.dotSize,
      dotGap: Number.isFinite(raw.dotGap) ? Number(raw.dotGap) : DEFAULT_DIMENSIONS.dotGap,
      templatePath,
      habitKey: toHabitKey(title),
      habitTag: `#habit_${toHabitKey(title)}`
    };
  }
  async collectHabitStats(options) {
    const countsByISO = /* @__PURE__ */ new Map();
    const hasByISO = /* @__PURE__ */ new Set();
    const lastTsByISO = /* @__PURE__ */ new Map();
    const folder = trimSlashes(options.dailyFolder);
    const folderPrefix = folder ? `${folder}/` : "";
    const files = this.app.vault.getMarkdownFiles().filter((file) => folder ? file.path.startsWith(folderPrefix) : true);
    const habitRegex = new RegExp(`${escapeRegExp("#habit_")}([^\\s#]+)(?:\\s+(\\d{1,2}:\\d{2}))?`, "gim");
    const needle = options.habitKey.toLowerCase();
    for (const file of files) {
      const day = parseYMD(file.basename);
      if (!day)
        continue;
      const content = await this.app.vault.cachedRead(file);
      if (!content)
        continue;
      let match;
      while ((match = habitRegex.exec(content)) !== null) {
        const key = match[1]?.trim().toLowerCase();
        if (key !== needle)
          continue;
        const timeRaw = match[2]?.trim() ?? "00:00";
        const [hh, mm] = timeRaw.split(":").map((value) => parseInt(value, 10));
        if (Number.isNaN(hh) || Number.isNaN(mm))
          continue;
        const timestamp = makeLocalDate(day.y, day.mo, day.d, hh, mm);
        const iso = isoOf(day.y, day.mo, day.d);
        countsByISO.set(iso, (countsByISO.get(iso) ?? 0) + 1);
        hasByISO.add(iso);
        const previous = lastTsByISO.get(iso);
        if (!previous || timestamp > previous) {
          lastTsByISO.set(iso, timestamp);
        }
      }
    }
    const allowedGapH = Number.isFinite(options.warnHoursThreshold) ? Math.max(1, Number(options.warnHoursThreshold)) + 24 : 48;
    const allowedGapMs = allowedGapH * 36e5;
    const dayTimestamps = sortDatesAscending(lastTsByISO.values());
    const lastTs = dayTimestamps.length ? dayTimestamps[dayTimestamps.length - 1] : null;
    const streak = computeStreakByDays(dayTimestamps, allowedGapMs);
    return {
      countsByISO,
      hasByISO,
      lastTsByISO,
      lastTs,
      streak,
      allowedGapH,
      allowedGapMs
    };
  }
  renderError(el, message) {
    el.empty();
    el.createEl("pre", { text: message });
  }
  applyLayoutStyles(container, options) {
    container.style.setProperty("--habit-cell-size", `${options.cellSize}px`);
    container.style.setProperty("--habit-cell-gap", `${options.cellGap}px`);
    container.style.setProperty("--habit-dot-size", `${options.dotSize}px`);
    container.style.setProperty("--habit-dot-gap", `${options.dotGap}px`);
  }
  renderHabitButton(source, el, _ctx) {
    const blockOptions = this.parseBlock(source);
    const options = this.resolveOptions(blockOptions);
    if (!options) {
      this.renderError(el, t("ui.errorNoTitle"));
      return;
    }
    void this.mountHabitButton(el, options);
  }
  async mountHabitButton(el, options) {
    const stats = await this.collectHabitStats(options);
    el.empty();
    const card = el.createDiv({ cls: "dv-habit-card" });
    const iconBtn = card.createEl("button", {
      cls: "dv-habit-iconbtn",
      text: options.icon || "\u2705",
      attr: { title: t("ui.markHabit", options.normalizedTitle) }
    });
    const right = card.createDiv({ cls: "dv-habit-right" });
    const titleRow = right.createDiv();
    titleRow.createDiv({ cls: "dv-habit-title", text: options.normalizedTitle });
    const heat = right.createDiv({ cls: "dv-habit-heat-row" });
    const meta = right.createDiv({ cls: "dv-habit-meta" });
    const lastEl = meta.createSpan({ cls: "last" });
    meta.createSpan({ cls: "bullet", text: "\u2022" });
    const streakEl = meta.createSpan({ cls: "streak" });
    this.applyLayoutStyles(card, options);
    const state = {
      options,
      stats,
      heat,
      meta: { lastEl, streakEl },
      card,
      iconBtn
    };
    const renderHeat = () => {
      if (options.heatLayout === "grid")
        this.renderHeatGrid(state);
      else
        this.renderHeatRow(state);
    };
    const renderMeta = () => {
      const { stats: currentStats } = state;
      const { lastEl: lastElement, streakEl: streakElement } = state.meta;
      lastElement.textContent = humanAgoShort(currentStats.lastTs);
      const hoursSinceLast = currentStats.lastTs ? (Date.now() - currentStats.lastTs.getTime()) / 36e5 : Infinity;
      const isStreakAlive = currentStats.streak > 0;
      const shouldWarn = typeof options.warnHoursThreshold === "number" && Number.isFinite(options.warnHoursThreshold) && hoursSinceLast >= options.warnHoursThreshold && !isStreakAlive;
      lastElement.classList.toggle("is-overdue", shouldWarn);
      const streakText = currentStats.streak > 0 ? t("meta.streak", currentStats.streak) : t("meta.streakZero");
      streakElement.textContent = streakText;
      streakElement.classList.toggle("is-zero", currentStats.streak === 0);
      const remH = Number.isFinite(hoursSinceLast) ? currentStats.allowedGapH - hoursSinceLast : -Infinity;
      if (currentStats.streak > 0 && remH > 0 && remH <= 24) {
        const hint = streakElement.createSpan({ cls: "time-left" });
        const hrs = Math.ceil(remH);
        hint.textContent = ` ${t("overdue.label", hrs)}`;
      }
    };
    const refresh = () => {
      renderHeat();
      renderMeta();
      const today = today0();
      const isoToday = isoOf(today.getFullYear(), today.getMonth() + 1, today.getDate());
      const doneToday = state.stats.hasByISO.has(isoToday);
      card.classList.toggle("is-done", doneToday);
      iconBtn.classList.toggle("is-done", doneToday);
      iconBtn.textContent = doneToday ? "\u2713" : options.icon || "\u2705";
      iconBtn.setAttribute("aria-pressed", doneToday ? "true" : "false");
    };
    refresh();
    iconBtn.addEventListener("click", async () => {
      try {
        const timestamp = await this.logHabitEntry(options);
        if (!timestamp)
          return;
        const iso = isoOf(
          timestamp.getFullYear(),
          timestamp.getMonth() + 1,
          timestamp.getDate()
        );
        state.stats.countsByISO.set(
          iso,
          (state.stats.countsByISO.get(iso) ?? 0) + 1
        );
        state.stats.hasByISO.add(iso);
        state.stats.lastTsByISO.set(iso, timestamp);
        const sorted = sortDatesAscending(state.stats.lastTsByISO.values());
        state.stats.lastTs = sorted.length ? sorted[sorted.length - 1] : null;
        state.stats.streak = computeStreakByDays(sorted, state.stats.allowedGapMs);
        refresh();
      } catch (error) {
        console.error("[habit-button] append error", error);
        new import_obsidian2.Notice(t("ui.noticeError"), 4e3);
      }
    });
  }
  renderHeatRow(state) {
    const { options, stats, heat } = state;
    heat.className = "dv-habit-heat-row";
    heat.empty();
    const start = today0();
    start.setDate(start.getDate() - (options.days - 1));
    for (let i = 0; i < options.days; i++) {
      const current = new Date(start);
      current.setDate(start.getDate() + i);
      const iso = isoOf(current.getFullYear(), current.getMonth() + 1, current.getDate());
      const count = stats.countsByISO.get(iso) ?? 0;
      const level = Math.max(0, Math.min(4, count));
      const dot = heat.createDiv({
        cls: `dv-habit-dot ${level ? `dot-l${Math.min(level, 4)}` : ""}`.trim()
      });
      dot.title = `${iso}: ${count || 0}`;
    }
    requestAnimationFrame(() => {
      heat.scrollLeft = heat.scrollWidth;
    });
  }
  renderHeatGrid(state) {
    const { options, stats, heat } = state;
    heat.className = "dv-habit-heat-grid";
    heat.empty();
    const today = today0();
    const isoDow = (today.getDay() + 6) % 7;
    const start = new Date(today);
    start.setDate(today.getDate() - isoDow - (options.weeks - 1) * 7);
    for (let w = 0; w < options.weeks; w++) {
      const column = heat.createDiv({ cls: "dv-habit-col" });
      for (let i = 0; i < 7; i++) {
        const current = new Date(start);
        current.setDate(start.getDate() + w * 7 + i);
        const y = current.getFullYear();
        const mo = current.getMonth() + 1;
        const d = current.getDate();
        const iso = isoOf(y, mo, d);
        const count = stats.countsByISO.get(iso) ?? 0;
        const level = Math.max(0, Math.min(4, count));
        const isFuture = current > today;
        const cell = column.createDiv({
          cls: `dv-habit-cell ${isFuture ? "is-future" : ""} ${level ? `dot-l${Math.min(level, 4)}` : ""}`.trim()
        });
        cell.title = `${iso}: ${count || 0}`;
      }
    }
    requestAnimationFrame(() => {
      heat.scrollLeft = heat.scrollWidth;
    });
  }
  async logHabitEntry(options) {
    const now = /* @__PURE__ */ new Date();
    const yyyy = now.getFullYear();
    const mm = pad2(now.getMonth() + 1);
    const dd = pad2(now.getDate());
    const fileName = `${yyyy}-${mm}-${dd}.md`;
    const folder = trimSlashes(options.dailyFolder);
    const path = folder ? `${folder}/${fileName}` : fileName;
    const habitLine = `
- ${options.habitTag} ${nowHHMM(now)}
`;
    let file = this.app.vault.getAbstractFileByPath(path);
    if (!file) {
      let templateContent = "";
      if (options.templatePath) {
        const templateFile = this.app.vault.getAbstractFileByPath(options.templatePath);
        if (templateFile instanceof import_obsidian2.TFile) {
          try {
            templateContent = await this.app.vault.read(templateFile);
          } catch (error) {
            console.warn("Habit Button: unable to read template", error);
          }
        }
      }
      if (templateContent) {
        templateContent = ensureTrailingNewline(templateContent);
      }
      await this.app.vault.create(path, `${templateContent}${habitLine}`);
      file = this.app.vault.getAbstractFileByPath(path);
    } else {
      await this.app.vault.append(file, habitLine);
    }
    new import_obsidian2.Notice(t("ui.noticeAdded", options.normalizedTitle));
    return now;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
