/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HabitButtonPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  dailyFolder: "daily",
  defaultLayout: "grid",
  weeks: 26,
  days: 240,
  templatePath: "meta/templates/daily note template.md"
};
var HabitButtonSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Habit Button" });
    new import_obsidian.Setting(containerEl).setName("Daily folder").setDesc("Folder that contains daily notes to scan for habits.").addText(
      (text) => text.setPlaceholder("daily").setValue(this.plugin.settings.dailyFolder).onChange(async (value) => {
        this.plugin.settings.dailyFolder = value.trim() || "daily";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Daily note template").setDesc("Optional template used when creating a missing daily note.").addText(
      (text) => text.setPlaceholder("meta/templates/daily note template.md").setValue(this.plugin.settings.templatePath).onChange(async (value) => {
        this.plugin.settings.templatePath = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default layout").setDesc("Heatmap layout to use when none is specified in the block.").addDropdown(
      (dropdown) => dropdown.addOptions({ grid: "Grid", row: "Row" }).setValue(this.plugin.settings.defaultLayout).onChange(async (value) => {
        if (value === "grid" || value === "row") {
          this.plugin.settings.defaultLayout = value;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Grid weeks").setDesc("Number of weeks to show in grid heatmap layout.").addSlider(
      (slider) => slider.setLimits(4, 52, 1).setValue(this.plugin.settings.weeks).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.weeks = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Row days").setDesc("Number of days to show in row heatmap layout.").addSlider(
      (slider) => slider.setLimits(30, 365, 5).setValue(this.plugin.settings.days).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.days = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// styles.css
var styles_default = '.dv-habit-card {\n  display: flex;\n  align-items: flex-start;\n  background: var(--background-primary);\n  border-radius: 16px;\n  transition: opacity 0.18s ease, background 0.18s ease, border-color 0.18s ease;\n}\n\n.dv-habit-card.is-done {\n  opacity: 0.5;\n}\n\n.dv-habit-iconbtn {\n  width: 70px;\n  height: 70px;\n  border-radius: 12px;\n  font-size: 42px;\n  line-height: 1;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  border: 1px solid var(--background-modifier-border);\n  background: var(--background-secondary);\n  cursor: pointer;\n  user-select: none;\n  transition: transform 0.06s ease, background 0.18s ease, border-color 0.18s ease, color 0.18s ease;\n}\n\n.dv-habit-iconbtn:active {\n  transform: scale(0.98);\n}\n\n.dv-habit-iconbtn.is-done {\n  background: #10b981;\n  border-color: #10b981;\n  color: #052e16;\n}\n\n.dv-habit-right {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n  min-width: 0;\n  flex: 1;\n  margin-left: 16px;\n}\n\n.dv-habit-title {\n  font-weight: 600;\n  line-height: 1.2;\n}\n\n.dv-habit-meta {\n  display: flex;\n  gap: 8px;\n  align-items: center;\n  font-size: 0.95em;\n}\n\n.dv-habit-meta .last {\n  color: var(--text-muted);\n}\n\n.dv-habit-meta .last.is-overdue {\n  color: #b45309;\n  font-weight: 600;\n}\n\n.dv-habit-meta .bullet {\n  opacity: 0.6;\n}\n\n.dv-habit-meta .streak {\n  color: #059669;\n  font-weight: 600;\n}\n\n.dv-habit-meta .streak.is-zero {\n  color: var(--text-muted);\n}\n\n.dv-habit-meta .streak .time-left {\n  color: #b45309;\n  font-weight: 600;\n}\n\n.dv-habit-heat-row {\n  --dot-size: var(--habit-dot-size, 8px);\n  --dot-gap: var(--habit-dot-gap, 4px);\n  display: flex;\n  align-items: center;\n  gap: var(--dot-gap);\n  overflow: hidden;\n}\n\n.dv-habit-dot {\n  width: var(--dot-size);\n  height: var(--dot-size);\n  border-radius: 999px;\n  background: var(--background-modifier-border);\n  flex: 0 0 var(--dot-size);\n}\n\n.dv-habit-heat-grid {\n  --cell-size: var(--habit-cell-size, 9px);\n  --cell-gap: var(--habit-cell-gap, 3px);\n  display: flex;\n  gap: var(--cell-gap);\n  overflow: auto;\n  align-items: flex-start;\n}\n\n.dv-habit-col {\n  display: flex;\n  flex-direction: column;\n  gap: var(--cell-gap);\n}\n\n.dv-habit-cell {\n  width: var(--cell-size);\n  height: var(--cell-size);\n  border-radius: 2px;\n  background: var(--background-modifier-border);\n  transition: opacity 0.12s ease;\n}\n\n.dv-habit-cell.is-future {\n  opacity: 0 !important;\n  background: transparent !important;\n  pointer-events: none;\n}\n\n.dot-l1 {\n  background: #aceebb !important;\n}\n\n.dot-l2 {\n  background: #4ac26b !important;\n}\n\n.dot-l3 {\n  background: #2da44e !important;\n}\n\n.dot-l4 {\n  background: #116329 !important;\n}\n\n.dv-habit-card,\n.dv-habit-card * {\n  list-style: none !important;\n}\n\n.dv-habit-card ul,\n.dv-habit-card ol {\n  margin: 0 !important;\n  padding: 0 !important;\n}\n\n.dv-habit-card li::marker {\n  content: "" !important;\n}\n';

// src/main.ts
var DEFAULT_DIMENSIONS = {
  cellSize: 9,
  cellGap: 3,
  dotSize: 8,
  dotGap: 4
};
function pad2(n) {
  return String(n).padStart(2, "0");
}
function normalizeWhitespace(value) {
  return value.trim().replace(/\s+/g, " ");
}
function capitalizeFirst(value) {
  if (!value)
    return value;
  return value[0].toUpperCase() + value.slice(1);
}
function escapeRegExp(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function toHabitKey(value) {
  const lower = value.toLowerCase();
  return lower.replace(/\s+/g, "_").replace(/[^a-zа-яё0-9_]/gi, "").replace(/_+/g, "_").replace(/^_+|_+$/g, "");
}
function nowHHMM(now) {
  return `${pad2(now.getHours())}:${pad2(now.getMinutes())}`;
}
function parseYMD(name) {
  const match = /^(\d{4})-(\d{2})-(\d{2})$/.exec(name);
  if (!match)
    return null;
  return { y: Number(match[1]), mo: Number(match[2]), d: Number(match[3]) };
}
function makeLocalDate(y, mo, d, hh = 0, mm = 0) {
  return new Date(y, mo - 1, d, hh, mm, 0, 0);
}
function isoOf(y, mo, d) {
  return `${y}-${pad2(mo)}-${pad2(d)}`;
}
function today0() {
  const now = /* @__PURE__ */ new Date();
  now.setHours(0, 0, 0, 0);
  return now;
}
function humanAgoShort(ts) {
  if (!ts)
    return "\u2014";
  const diffMs = Date.now() - ts.getTime();
  const mins = Math.max(0, Math.floor(diffMs / 6e4));
  const days = Math.floor(mins / 1440);
  const hours = Math.floor(mins % 1440 / 60);
  const minutes = mins % 60;
  if (days === 0 && hours < 1) {
    return mins < 2 ? "\u0442\u043E\u043B\u044C\u043A\u043E \u0447\u0442\u043E" : `${minutes}\u043C \u043D\u0430\u0437\u0430\u0434`;
  }
  if (days === 0) {
    return `${hours}\u0447 \u043D\u0430\u0437\u0430\u0434`;
  }
  if (days < 2) {
    return `${days * 24 + hours}\u0447. \u043D\u0430\u0437\u0430\u0434`;
  }
  return `${days} \u0434\u043D. \u043D\u0430\u0437\u0430\u0434`;
}
function computeStreakByDays(days, allowedGapMs) {
  if (!days.length)
    return 0;
  const now = Date.now();
  const last = days[days.length - 1];
  if (now - last.getTime() > allowedGapMs)
    return 0;
  let streak = 1;
  for (let i = days.length - 2; i >= 0; i--) {
    if (days[i + 1].getTime() - days[i].getTime() <= allowedGapMs)
      streak++;
    else
      break;
  }
  return streak;
}
function sortDatesAscending(list) {
  return Array.from(list).sort((a, b) => a.getTime() - b.getTime());
}
function ensureTrailingNewline(value) {
  if (!value.endsWith("\n"))
    return `${value}
`;
  return value;
}
function trimSlashes(path) {
  return path.replace(/^\/+|\/+$/g, "");
}
var HabitButtonPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.styleEl = null;
  }
  async onload() {
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor(
      "habit-button",
      (source, el, ctx) => this.renderHabitButton(source, el, ctx)
    );
    this.addCommand({
      id: "habit-button-insert-block",
      name: "Insert habit button block",
      editorCallback: (editor) => {
        const cursor = editor.getCursor();
        const snippet = "```habit-button\ntitle: \u041C\u043E\u044F \u043F\u0440\u0438\u0432\u044B\u0447\u043A\u0430\nheatLayout: grid\n```\n";
        editor.replaceRange(snippet, cursor);
      }
    });
    this.addSettingTab(new HabitButtonSettingTab(this.app, this));
    this.injectStyles();
  }
  onunload() {
    this.disposeStyles();
  }
  injectStyles() {
    if (this.styleEl)
      return;
    const style = document.createElement("style");
    style.id = "habit-button-styles";
    style.textContent = styles_default;
    document.head.appendChild(style);
    this.styleEl = style;
    this.register(() => this.disposeStyles());
  }
  disposeStyles() {
    if (this.styleEl?.parentElement) {
      this.styleEl.parentElement.removeChild(this.styleEl);
    }
    this.styleEl = null;
  }
  parseBlock(source) {
    const trimmed = source.trim();
    if (!trimmed)
      return {};
    try {
      const parsed = (0, import_obsidian2.parseYaml)(trimmed);
      if (typeof parsed === "object" && parsed)
        return parsed;
      return {};
    } catch (error) {
      console.warn("Habit Button: failed to parse block", error);
      return {};
    }
  }
  resolveOptions(raw) {
    const title = raw.title ? normalizeWhitespace(String(raw.title)) : "";
    if (!title)
      return null;
    const normalizedTitle = capitalizeFirst(title);
    const layout = raw.heatLayout === "row" ? "row" : raw.heatLayout === "grid" ? "grid" : this.settings.defaultLayout;
    const weeks = Number.isFinite(raw.weeks) ? Math.max(1, Number(raw.weeks)) : this.settings.weeks;
    const days = Number.isFinite(raw.days) ? Math.max(1, Number(raw.days)) : this.settings.days;
    const dailyFolder = raw.dailyFolder?.trim().length ? trimSlashes(raw.dailyFolder.trim()) : this.settings.dailyFolder;
    const templateCandidate = raw.templatePath?.trim() || this.settings.templatePath?.trim();
    const templatePath = templateCandidate ? templateCandidate : void 0;
    return {
      title,
      normalizedTitle,
      icon: raw.icon,
      warnHoursThreshold: typeof raw.warnHoursThreshold === "number" ? raw.warnHoursThreshold : void 0,
      dailyFolder,
      heatLayout: layout,
      weeks,
      days,
      cellSize: Number.isFinite(raw.cellSize) ? Number(raw.cellSize) : DEFAULT_DIMENSIONS.cellSize,
      cellGap: Number.isFinite(raw.cellGap) ? Number(raw.cellGap) : DEFAULT_DIMENSIONS.cellGap,
      dotSize: Number.isFinite(raw.dotSize) ? Number(raw.dotSize) : DEFAULT_DIMENSIONS.dotSize,
      dotGap: Number.isFinite(raw.dotGap) ? Number(raw.dotGap) : DEFAULT_DIMENSIONS.dotGap,
      templatePath,
      habitKey: toHabitKey(title),
      habitTag: `#habit_${toHabitKey(title)}`
    };
  }
  async collectHabitStats(options) {
    const countsByISO = /* @__PURE__ */ new Map();
    const hasByISO = /* @__PURE__ */ new Set();
    const lastTsByISO = /* @__PURE__ */ new Map();
    const folder = trimSlashes(options.dailyFolder);
    const folderPrefix = folder ? `${folder}/` : "";
    const files = this.app.vault.getMarkdownFiles().filter((file) => folder ? file.path.startsWith(folderPrefix) : true);
    const habitRegex = new RegExp(`${escapeRegExp("#habit_")}([^\\s#]+)(?:\\s+(\\d{1,2}:\\d{2}))?`, "gim");
    const needle = options.habitKey.toLowerCase();
    for (const file of files) {
      const day = parseYMD(file.basename);
      if (!day)
        continue;
      const content = await this.app.vault.cachedRead(file);
      if (!content)
        continue;
      let match;
      while ((match = habitRegex.exec(content)) !== null) {
        const key = match[1]?.trim().toLowerCase();
        if (key !== needle)
          continue;
        const timeRaw = match[2]?.trim() ?? "00:00";
        const [hh, mm] = timeRaw.split(":").map((value) => parseInt(value, 10));
        if (Number.isNaN(hh) || Number.isNaN(mm))
          continue;
        const timestamp = makeLocalDate(day.y, day.mo, day.d, hh, mm);
        const iso = isoOf(day.y, day.mo, day.d);
        countsByISO.set(iso, (countsByISO.get(iso) ?? 0) + 1);
        hasByISO.add(iso);
        const previous = lastTsByISO.get(iso);
        if (!previous || timestamp > previous) {
          lastTsByISO.set(iso, timestamp);
        }
      }
    }
    const allowedGapH = Number.isFinite(options.warnHoursThreshold) ? Math.max(1, Number(options.warnHoursThreshold)) + 24 : 48;
    const allowedGapMs = allowedGapH * 36e5;
    const dayTimestamps = sortDatesAscending(lastTsByISO.values());
    const lastTs = dayTimestamps.length ? dayTimestamps[dayTimestamps.length - 1] : null;
    const streak = computeStreakByDays(dayTimestamps, allowedGapMs);
    return {
      countsByISO,
      hasByISO,
      lastTsByISO,
      lastTs,
      streak,
      allowedGapH,
      allowedGapMs
    };
  }
  renderError(el, message) {
    el.empty();
    el.createEl("pre", { text: message });
  }
  applyLayoutStyles(container, options) {
    container.style.setProperty("--habit-cell-size", `${options.cellSize}px`);
    container.style.setProperty("--habit-cell-gap", `${options.cellGap}px`);
    container.style.setProperty("--habit-dot-size", `${options.dotSize}px`);
    container.style.setProperty("--habit-dot-gap", `${options.dotGap}px`);
  }
  renderHabitButton(source, el, _ctx) {
    const blockOptions = this.parseBlock(source);
    const options = this.resolveOptions(blockOptions);
    if (!options) {
      this.renderError(el, "[habit-button] \u041D\u0435 \u0437\u0430\u0434\u0430\u043D title");
      return;
    }
    void this.mountHabitButton(el, options);
  }
  async mountHabitButton(el, options) {
    const stats = await this.collectHabitStats(options);
    el.empty();
    const card = el.createDiv({ cls: "dv-habit-card" });
    const iconBtn = card.createEl("button", {
      cls: "dv-habit-iconbtn",
      text: options.icon || "\u2705",
      attr: { title: `\u041E\u0442\u043C\u0435\u0442\u0438\u0442\u044C: ${options.normalizedTitle}` }
    });
    const right = card.createDiv({ cls: "dv-habit-right" });
    const titleRow = right.createDiv();
    titleRow.createDiv({ cls: "dv-habit-title", text: options.normalizedTitle });
    const heat = right.createDiv({ cls: "dv-habit-heat-row" });
    const meta = right.createDiv({ cls: "dv-habit-meta" });
    const lastEl = meta.createSpan({ cls: "last" });
    meta.createSpan({ cls: "bullet", text: "\u2022" });
    const streakEl = meta.createSpan({ cls: "streak" });
    this.applyLayoutStyles(card, options);
    const state = {
      options,
      stats,
      heat,
      meta: { lastEl, streakEl },
      card,
      iconBtn
    };
    const renderHeat = () => {
      if (options.heatLayout === "grid")
        this.renderHeatGrid(state);
      else
        this.renderHeatRow(state);
    };
    const renderMeta = () => {
      const { stats: currentStats } = state;
      const { lastEl: lastElement, streakEl: streakElement } = state.meta;
      lastElement.textContent = humanAgoShort(currentStats.lastTs);
      const hoursSinceLast = currentStats.lastTs ? (Date.now() - currentStats.lastTs.getTime()) / 36e5 : Infinity;
      const isStreakAlive = currentStats.streak > 0;
      const shouldWarn = typeof options.warnHoursThreshold === "number" && Number.isFinite(options.warnHoursThreshold) && hoursSinceLast >= options.warnHoursThreshold && !isStreakAlive;
      lastElement.classList.toggle("is-overdue", shouldWarn);
      const streakPrefix = `\u0421\u0442\u0440\u0438\u043A: ${currentStats.streak} \u0434\u043D.`;
      streakElement.textContent = streakPrefix;
      streakElement.classList.toggle("is-zero", currentStats.streak === 0);
      const remH = Number.isFinite(hoursSinceLast) ? currentStats.allowedGapH - hoursSinceLast : -Infinity;
      if (currentStats.streak > 0 && remH > 0 && remH <= 24) {
        const hint = streakElement.createSpan({ cls: "time-left" });
        const hrs = Math.ceil(remH);
        hint.textContent = ` <${hrs}\u0447. \u{1F525}`;
      }
    };
    const refresh = () => {
      renderHeat();
      renderMeta();
      const today = today0();
      const isoToday = isoOf(today.getFullYear(), today.getMonth() + 1, today.getDate());
      const doneToday = state.stats.hasByISO.has(isoToday);
      card.classList.toggle("is-done", doneToday);
      iconBtn.classList.toggle("is-done", doneToday);
      iconBtn.textContent = doneToday ? "\u2713" : options.icon || "\u2705";
      iconBtn.setAttribute("aria-pressed", doneToday ? "true" : "false");
    };
    refresh();
    iconBtn.addEventListener("click", async () => {
      try {
        const timestamp = await this.logHabitEntry(options);
        if (!timestamp)
          return;
        const iso = isoOf(
          timestamp.getFullYear(),
          timestamp.getMonth() + 1,
          timestamp.getDate()
        );
        state.stats.countsByISO.set(
          iso,
          (state.stats.countsByISO.get(iso) ?? 0) + 1
        );
        state.stats.hasByISO.add(iso);
        state.stats.lastTsByISO.set(iso, timestamp);
        const sorted = sortDatesAscending(state.stats.lastTsByISO.values());
        state.stats.lastTs = sorted.length ? sorted[sorted.length - 1] : null;
        state.stats.streak = computeStreakByDays(sorted, state.stats.allowedGapMs);
        refresh();
      } catch (error) {
        console.error("[habit-button] append error", error);
        new import_obsidian2.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0438\u0441\u0438 \u043F\u0440\u0438\u0432\u044B\u0447\u043A\u0438", 4e3);
      }
    });
  }
  renderHeatRow(state) {
    const { options, stats, heat } = state;
    heat.className = "dv-habit-heat-row";
    heat.empty();
    const start = today0();
    start.setDate(start.getDate() - (options.days - 1));
    for (let i = 0; i < options.days; i++) {
      const current = new Date(start);
      current.setDate(start.getDate() + i);
      const iso = isoOf(current.getFullYear(), current.getMonth() + 1, current.getDate());
      const count = stats.countsByISO.get(iso) ?? 0;
      const level = Math.max(0, Math.min(4, count));
      const dot = heat.createDiv({
        cls: `dv-habit-dot ${level ? `dot-l${Math.min(level, 4)}` : ""}`.trim()
      });
      dot.title = `${iso}: ${count || 0}`;
    }
    requestAnimationFrame(() => {
      heat.scrollLeft = heat.scrollWidth;
    });
  }
  renderHeatGrid(state) {
    const { options, stats, heat } = state;
    heat.className = "dv-habit-heat-grid";
    heat.empty();
    const today = today0();
    const isoDow = (today.getDay() + 6) % 7;
    const start = new Date(today);
    start.setDate(today.getDate() - isoDow - (options.weeks - 1) * 7);
    for (let w = 0; w < options.weeks; w++) {
      const column = heat.createDiv({ cls: "dv-habit-col" });
      for (let i = 0; i < 7; i++) {
        const current = new Date(start);
        current.setDate(start.getDate() + w * 7 + i);
        const y = current.getFullYear();
        const mo = current.getMonth() + 1;
        const d = current.getDate();
        const iso = isoOf(y, mo, d);
        const count = stats.countsByISO.get(iso) ?? 0;
        const level = Math.max(0, Math.min(4, count));
        const isFuture = current > today;
        const cell = column.createDiv({
          cls: `dv-habit-cell ${isFuture ? "is-future" : ""} ${level ? `dot-l${Math.min(level, 4)}` : ""}`.trim()
        });
        cell.title = `${iso}: ${count || 0}`;
      }
    }
    requestAnimationFrame(() => {
      heat.scrollLeft = heat.scrollWidth;
    });
  }
  async logHabitEntry(options) {
    const now = /* @__PURE__ */ new Date();
    const yyyy = now.getFullYear();
    const mm = pad2(now.getMonth() + 1);
    const dd = pad2(now.getDate());
    const fileName = `${yyyy}-${mm}-${dd}.md`;
    const folder = trimSlashes(options.dailyFolder);
    const path = folder ? `${folder}/${fileName}` : fileName;
    const habitLine = `
- ${options.habitTag} ${nowHHMM(now)}
`;
    let file = this.app.vault.getAbstractFileByPath(path);
    if (!file) {
      let templateContent = "";
      if (options.templatePath) {
        const templateFile = this.app.vault.getAbstractFileByPath(options.templatePath);
        if (templateFile instanceof import_obsidian2.TFile) {
          try {
            templateContent = await this.app.vault.read(templateFile);
          } catch (error) {
            console.warn("Habit Button: unable to read template", error);
          }
        }
      }
      if (templateContent) {
        templateContent = ensureTrailingNewline(templateContent);
      }
      await this.app.vault.create(path, `${templateContent}${habitLine}`);
      file = this.app.vault.getAbstractFileByPath(path);
    } else {
      await this.app.vault.append(file, habitLine);
    }
    new import_obsidian2.Notice(`\u0414\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043E: ${options.normalizedTitle}`);
    return now;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
